{
    "contents" : "### check if mfergm works fine\n\n# library mfergm (also loads ergm, networks)\nlibrary(mfergm)\n\n# set seed\nset.seed(1977)\n\n# size of the network\nn <- 100\n\n# attributes\nx <- rnorm(n,0,1)\n\n# parameters location\np <- c(1,2)\nq <- 1\n\n# change stats to use\ndt <- matrix(0, ncol = p[2], nrow = 2)\ndt[,1] <- c(1,1)\ndt[,2] <- c(1,1)\n\n# true parameters\ntheta = c(-1.0,2.0)\n\n# tolerance for mf\ntol = 0.000001 \n\n## create network from random erdos renyi\n#g <- network(matrix(rbinom(n^2,1,exp(theta[1]/(1+exp(theta[1]) )  )), \n#                    nrow = n, ncol = n), directed = FALSE)\ng <- initialize.network(theta, n, directed = FALSE)\n\n## generate network from simulation of ergm\ng0 <- simulate(~edges+kstar(2), \n                    nsim = 1, \n                    coef = theta*c(2,1/n ),\n                    basis = g,\n                    control=control.simulate(\n                      MCMC.burnin=1000000,\n                      MCMC.interval=100)\n               )\n\ng0\n\ng0 <- simulate(~edges+kstar(2), \n               nsim = 100, \n               coef = theta*c(2,1/n ),\n               basis = g,\n               control=control.simulate(\n                 MCMC.burnin=1000,\n                 MCMC.interval=100)\n)\n\ng0\n\ntobs <- data.frame(matrix(NA,ncol =2 , nrow = 100))\nfor (i in 1:100) {\n  formula <- g0[[i]] ~ edges + kstar(2)\n  tobs[i,] <- summary(formula)/(c((n^2)/2, n^3))  \n}\n\n# the following works fine, so you can create a loop on the\n# formulas for each graph\nformula <- g0[[1]] ~ edges + kstar(2)\n\n\n## compute suff stats for the simulated network\nformula <- g0 ~ edges + kstar(2)\ntobs <- summary(formula)/(c((n^2)/2, n^3))\ntobs\n\nsum(theta*tobs)\npotential <- theta %*% tobs\n\n\n## mf approximation\nnsim <- 500 # number of re-starts of the algorithm\nlogc <- rep(0,nsim)\nfor (sim in 1:nsim) {\n  mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)\n  diag(mu) <- 0 \n  psi <- logconstant_mf(p, mu, theta, x, dt, tol) \n  psi$psi\n  logc[sim] <- psi$psi\n}\n\nlogc\nsort(logc)\npsi_mf <- max(logc)\n\n# compute log likelihood value\nloglik <- potential - psi_mf\n\n\n### solution 1: grid of parameters, evaluate log-likelihood\n###             at each grid point, interpolate\nformula <- g0 ~ edges + kstar(2)\ntobs <- summary(formula)/(c(n^2, n^3))\n\na <- seq(-3,5,.5)\nb <- seq(-20,20,1)\na <- seq(-5,5,.5)\nb <- seq(-5,10,.5)\nloglik_grid <- matrix(NA, nrow = length(a), ncol = length(b))\n\n## loop around the grid \nfor (i1 in 1:length(a)) {\n  for (j1 in 1: length(b)) {\n    ## to compute suff stats\n    theta <- c(a[i1],b[j1])\n    ## compute potential\n    potential <-theta %*% tobs\n    \n    \n    ## mf approximation\n    nsim <- 50 # number of re-starts of the algorithm\n    logc <- rep(0,nsim)\n    for (sim in 1:nsim) {\n      mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)\n      diag(mu) <- 0 \n      psi <- logconstant_mf(p, mu, theta, x, dt, tol) \n      psi$psi\n      logc[sim] <- psi$psi\n    }\n    \n    psi_mf <- max(logc)\n    \n    # compute log likelihood value\n    loglik <- potential - psi_mf\n    loglik_grid[i1,j1] <- loglik\n  }\n}\n\ncontour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(gamma), \n        xlim=c(-4,-2),ylim=c(0,1))\n\n\ncontour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(gamma), \n        xlim=c(-3,0),ylim=c(-1,1))\n\ncontour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(gamma), \n        xlim=c(1,4),ylim=c(-1,1))\n\n\ncontour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(gamma), \n        xlim=c(1,4),ylim=c(-6,-4))\n\ncontour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(gamma), \n        xlim=c(1,4),ylim=c(-6,-4))\n\n\ncontour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(gamma) )\n\n\n### solution 2: use nelder-mead\n\n\n### solution 3: use newton raphson with approximate gradient\n\n### comparison 1: estimate with ergm\nm1ergm <- ergm(formula, estimate = \"MLE\",\n          control=control.ergm(\n          MCMC.burnin=100000,\n          MCMC.interval=100)\n)\nsummary(m1ergm)\n0.042*(n)\n### comparison 2: estimate with bergm\n### comparison 3: estimate with GL-MLE He-Zheng\n\n### solution 4: approximate graph limits\n\n### solution 5: exact mean-field Chatterjee-Diaconis for this model\nformula <- g0 ~ edges + kstar(2)\ntobs <- summary(formula)/(c((n^2), n^3))\n\na <- seq(-5,5,.1)\nb <- seq(-5,10,.1)\nloglik_grid <- matrix(NA, nrow = length(a), ncol = length(b))\n\n## loop around the grid \nfor (i1 in 1:length(a)) {\n  for (j1 in 1: length(b)) {\n    ## to compute suff stats\n    theta <- c(a[i1],b[j1])\n    ## compute potential\n    potential <-theta %*% tobs\n    \n    \n    ## mf approximation      \n    mus <- mfcd(theta[1],theta[2])  \n    mus <-as.numeric(mus[1,])\n    # compute kappa_mf\n    kmu <- array(NA,length(mus))\n    kmu <- theta[1]*mus + .5*theta[2]*(mus^2) - 0.5*(mus*log(mus)+(1-mus)*log(1-mus))\n    psi_mf <- max(kmu)\n    loglik <- potential - psi_mf\n    #print(list(theta,loglik))\n    loglik_grid[i1,j1] <- loglik\n  }\n}\n\ncontour(a,b,loglik_grid, nlevels=1000,\n        xlab=expression(alpha),\n        ylab=expression(beta),\n        xlim = c(-2,-1), ylim = c(1.5,5)) \n\n\nfilled.contour(a,b,loglik_grid, nlevels=100,\n        xlab=expression(alpha),\n        ylab=expression(beta) )\n\nimage(a,b,loglik_grid, col = heat.colors(100),\n               xlab=expression(alpha),\n               ylab=expression(beta),\n      xlim = c(-5,-.5), ylim = c(1,5),)\npoints(x = -1.0, y = 2, pch = 19, col = \"red\")\n\ncontour(a,b,loglik_grid, nlevels=200,\n        xlab=expression(alpha),\n        ylab=expression(beta),\n        xlim = c(-2,-1), ylim = c(1.5,5),\n        add = TRUE) \nmax(loglik_grid[!is.nan(loglik_grid)])\n\nmaxind <- which(loglik_grid == max(loglik_grid[!is.nan(loglik_grid)]) , arr.ind=TRUE)\nloglik_grid[maxind]\npoints(x = a[maxind[1]], y = b[maxind[2]], pch =19, col =\"blue\")\n\nmaxind <- which(loglik_grid >= max(loglik_grid[!is.nan(loglik_grid)]-.001) , arr.ind=TRUE)\nloglik_grid[maxind]\n\n\ng0\nloglik\nmax(logc)\nexp(max(logc))\nexp(potential)\n",
    "created" : 1438614401897.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1747568193",
    "id" : "AF040A33",
    "lastKnownWriteTime" : 1444065323,
    "path" : "C:/Users/amele1/Dropbox/mfergm/programs/simulations_tests.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}