{
    "contents" : "#########################################################\n#\n# program: varapprox_netinst.R\n# author: Angelo Mele\n# date: 09/25/2013\n# last modified: 09/25/2013\n# description: Performs variational approximate inference\n#              using the representative agent approach (mu) \n#              approx likelihood, bayes, variational mcmc\n#\n#########################################################\n\n\n# cancel all variables from the memory\nrm(list=ls())\n\n# libraries\nlibrary(rootSolve)\n\n# set working directory (change this)\nsetwd(\"C:/Users/amele1/Dropbox/peersmoking/programs/toy_varapprox/toy_varapprox/Debug\")\n\n# set vectors of n and p\nnn<-c(100,200,500,1000)\npp<-c(10,50)\n#nn<-c(200)\n#pp<-c(10,50)\nnn<-1000\npp<-50\n# tolerance for var approx\ntol<-0.0001 \n\n# parameter grid for computations\na<- seq(-2,0,0.05)\nb<- seq(3,7,0.05)\na<- seq(-5,5,0.1)\nb<- seq(-5,10,0.1)\ngridstep<-0.025\na<- seq(-5,5,gridstep)\nb<- seq(-5,10,gridstep)\n#a<- seq(-2,0,gridstep)\n#b<- seq(0,10,gridstep)\n#a<- seq(-2,1,gridstep)\n#b<- seq(-1,10,gridstep)\n\nlength(a)\nlength(b)\n\n# matrix of parameters for computions\npars<-matrix(NA,nrow=length(a)*length(b),ncol=2)\nk=1\nfor (i in 1:length(a)) {\n  for (j in 1:length(b)) {\n    pars[k,]<-c(a[i],b[j])\n    k<-k+1\n  }\n}\n\n\n#### prior 1, independent normals N(0,10)N(0,1)\nlogprior1<-function(theta) {\n  logprior<-dnorm(theta[1], 0, 10, log = TRUE) + dnorm(theta[2], 0, 10, log = TRUE) \n  return(logprior)\n}\n\n#### prior 2, independent normals N(-1,5)N(5,5)\nlogprior2<-function(theta) {\n  logprior<-dnorm(theta[1], -1, 5, log = TRUE) + dnorm(theta[2], 5, 5, log = TRUE) \n  return(logprior)\n}\n\n#### prior 3, independent normals N(-1,1)N(5,1)\nlogprior3<-function(theta) {\n  logprior<-dnorm(theta[1], -1, 1, log = TRUE) + dnorm(theta[2], 5, 1, log = TRUE) \n  return(logprior)\n}\n\n#### prior 4, independent uniforms U(-5,5)N(0,10)\nlogprior4<-function(theta) {\n  logprior<-dunif(theta[1], -5, 5, log = TRUE) + dunif(theta[2], 0, 10, log = TRUE) \n  return(logprior)\n}\n\n\n##### vector of log priors\nlogpr1<-array(NA,length(pars[,1]))\nlogpr2<-array(NA,length(pars[,1]))\nlogpr3<-array(NA,length(pars[,1]))\nlogpr4<-array(NA,length(pars[,1]))\nlogpr1<-apply(pars,1,logprior1)\nlogpr2<-apply(pars,1,logprior2)\nlogpr3<-apply(pars,1,logprior3)\nlogpr4<-apply(pars,1,logprior4)\n\n\n### matrix of log priors\nlogp1<-matrix(0,nrow=length(a), ncol=length(b))\nlogp2<-matrix(0,nrow=length(a), ncol=length(b))\nlogp3<-matrix(0,nrow=length(a), ncol=length(b))\nlogp4<-matrix(0,nrow=length(a), ncol=length(b))\nfor (i in 1:length(a)) {\n  for (j in 1:length(b)) {\n    logp1[i,j]<-logprior1(c(a[i],b[j]))\n    logp2[i,j]<-logprior2(c(a[i],b[j]))\n    logp3[i,j]<-logprior3(c(a[i],b[j]))\n    logp4[i,j]<-logprior4(c(a[i],b[j]))\n  }\n}\n\n\n# table with summary estimates\ncol_headers<-c(expression(n), expression(p), expression(mu_alpha), expression(sig_alpha), expression(mode_alpha), expression(mu_gamma), expression(sig_gamma), expression(mode_gamma))\ntab<-matrix(NA,nrow=length(nn)*length(pp)*5, ncol=length(col_headers))\ncolnames(tab)<-col_headers\nrow_headers<-c(\"log-lik\", \"post 1\", \"post 2\", \"post 3\", \"post 4\")\nrownames(tab)<-rep(row_headers,length(nn)*length(pp))\n\n# text file\nsink(\"varapprox_netinst.txt\")\n\n# loop for analysis\nk<- 1  # table row for posterior summary\nkk<-1\nfor (ii in 1:length(nn)){\n  for (jj in 1:length(pp)) {\n    n<-nn[ii]\n    p<-pp[jj]\n    \n    # read files with data\n    filename<-paste(\"y_rand_netinst_n\",n,\"_p\",p,\".txt\", sep=\"\")\n    filename\n    y<-scan(filename)\n    filename<-paste(\"g_rand_netinst_n\",n,\"_p\",p,\".txt\", sep=\"\")\n    filename\n    gg<-scan(filename)\n    g<-matrix(gg,n,n)\n    g<-t(g)\n    \n    # data summaries\n    sumy<-sum(y)\n    ygy <- as.numeric( t(y) %*% g %*% y )\n    e<-sum(g)\n    ebar<-e/(n-1)\n    \n    \n    # mean field equation function\n    phi<-function(p,a,b) {\n      phi<-exp(a+b*ebar*p/n)/( 1+ exp(a+b*ebar*p/n) ) - p\n      return(phi)\n    }\n    \n    \n    ###### likelihood function\n    varloglik<- function(theta) {\n      # solve mean field equation\n      mus<-uniroot.all(phi, c(0, 1), tol = 0.0001, a=theta[1], b=theta[2])\n      mus<-as.numeric(mus)\n      # compute kappa_mf\n      kmu<-array(NA,length(mus))\n      kmu<- theta[1]*n*mus + .5*theta[2]*ebar*(mus^2) - n*(mus*log(mus)+(1-mus)*log(1-mus))\n      kmu<-max(kmu)\n      # compute log likelihood\n      varloglik<- theta[1]*sumy + .5*theta[2]*ygy/(n-1) - kmu \n      return<- varloglik \n    }\n    \n    # compute log-lik on the grid\n    z<-array(NA,length(pars[,1]))\n    start<-proc.time()\n    z<-apply(pars,1,varloglik)\n    end<-proc.time()\n    end-start\n    \n    \n    # create matrix with a in columns, and b in rows\n    loglik<-matrix(NA,nrow=length(a),ncol=length(b))\n    k<-1\n    for (i in 1:length(a)) {\n      for (j in 1:length(b)) {\n        loglik[i,j]<-z[k]\n        k<-k+1\n      }\n    }  \n    \n    # find max log lik \n    mle_est<-pars[which(z==max(z)),]\n    \n    ##### unnormalized posterior distribution (vector)\n    poster1un<-exp(z+logpr1)\n    poster2un<-exp(z+logpr2)\n    poster3un<-exp(z+logpr3)\n    poster4un<-exp(z+logpr4)\n    \n    #### unnormalized posterior distributions (mmtrix)\n    post1un<- exp(loglik+logp1)\n    post2un<- exp(loglik+logp2)\n    post3un<- exp(loglik+logp3)\n    post4un<- exp(loglik+logp4)\n    \n    #### posterior distributions (vector)\n    poster1<- poster1un/sum(poster1un)\n    poster2<- poster2un/sum(poster2un)\n    poster3<- poster3un/sum(poster3un)\n    poster4<- poster4un/sum(poster4un)\n    \n    #### posterior distributions (matrix)\n    post1<- post1un/sum(post1un)\n    post2<- post2un/sum(post2un)\n    post3<- post3un/sum(post3un)\n    post4<- post4un/sum(post4un)\n    \n    #### find posterior mode \n    poster1_mode<-pars[which(poster1un==max(poster1un)),]\n    poster2_mode<-pars[which(poster2un==max(poster2un)),]\n    poster3_mode<-pars[which(poster3un==max(poster3un)),]\n    poster4_mode<-pars[which(poster4un==max(poster4un)),]\n    \n    #### marginal posteriors\n    marg_a_post1 <- apply(post1*gridstep,1,sum)\n    marg_b_post1 <- apply(post1*gridstep,2,sum)\n    marg_a_post2 <- apply(post2*gridstep,1,sum)\n    marg_b_post2 <- apply(post2*gridstep,2,sum)\n    marg_a_post3 <- apply(post3*gridstep,1,sum)\n    marg_b_post3 <- apply(post3*gridstep,2,sum)\n    marg_a_post4 <- apply(post4*gridstep,1,sum)\n    marg_b_post4 <- apply(post4*gridstep,2,sum)\n    \n    #### posterior mean \n    poster1_mean<-array(NA,2)\n    poster2_mean<-array(NA,2)\n    poster3_mean<-array(NA,2)\n    poster4_mean<-array(NA,2)\n    poster1_mean[1] <- sum(a*marg_a_post1*gridstep)\n    poster2_mean[1] <- sum(a*marg_a_post2*gridstep)\n    poster3_mean[1] <- sum(a*marg_a_post3*gridstep)\n    poster4_mean[1] <- sum(a*marg_a_post4*gridstep)\n    poster1_mean[2] <- sum(b*marg_b_post1*gridstep)\n    poster2_mean[2] <- sum(b*marg_b_post2*gridstep)\n    poster3_mean[2] <- sum(b*marg_b_post3*gridstep)\n    poster4_mean[2] <- sum(b*marg_b_post4*gridstep)\n    \n    #### posterior std deviation\n    poster1_sd <- array(NA,2)\n    poster2_sd <- array(NA,2)\n    poster3_sd <- array(NA,2)\n    poster4_sd <- array(NA,2)\n    poster1_sd[1] <- sqrt(sum(gridstep*marg_a_post1 * (a - poster1_mean[1])^2 ))\n    poster2_sd[1] <- sqrt(sum(gridstep*marg_a_post2 * (a - poster2_mean[1])^2 ))\n    poster3_sd[1] <- sqrt(sum(gridstep*marg_a_post3 * (a - poster3_mean[1])^2 ))\n    poster4_sd[1] <- sqrt(sum(gridstep*marg_a_post4 * (a - poster4_mean[1])^2 ))\n    poster1_sd[2] <- sqrt(sum(gridstep*marg_b_post1 * (b - poster1_mean[2])^2 ))\n    poster2_sd[2] <- sqrt(sum(gridstep*marg_b_post2 * (b - poster2_mean[2])^2 ))\n    poster3_sd[2] <- sqrt(sum(gridstep*marg_b_post3 * (b - poster3_mean[2])^2 ))\n    poster4_sd[2] <- sqrt(sum(gridstep*marg_b_post4 * (b - poster4_mean[2])^2 ))\n    \n    \n    #### plots\n    plot_filename<-paste(\"varapprox_loglik_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,loglik, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(mle_est[1],mle_est[2], col=\"blue\", pch=19)\n    points(-1,5,pch=17,col=\"red\")\n    dev.off()\n    \n    plot_filename<-paste(\"varapprox_post1_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post1, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster1_mode[1],poster1_mode[2], col=\"blue\", pch=19)\n    #points(poster1_mean[1],poster1_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    \n    plot_filename<-paste(\"varapprox_post2_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post2, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster2_mode[1],poster2_mode[2], col=\"blue\", pch=19)\n    #points(poster2_mean[1],poster2_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    plot_filename<-paste(\"varapprox_post3_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post3, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster3_mode[1],poster3_mode[2], col=\"blue\", pch=19)\n    #points(poster3_mean[1],poster3_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    plot_filename<-paste(\"varapprox_post4_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post4, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster4_mode[1],poster4_mode[2], col=\"blue\", pch=19)\n    #points(poster4_mean[1],poster4_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    \n    plot_filename<-paste(\"varapprox_post1un_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post1un, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster1_mode[1],poster1_mode[2], col=\"blue\", pch=19)\n    #points(poster1_mean[1],poster1_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    \n    plot_filename<-paste(\"varapprox_post2un_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post2un, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster2_mode[1],poster2_mode[2], col=\"blue\", pch=19)\n    #points(poster2_mean[1],poster2_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    plot_filename<-paste(\"varapprox_post3un_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post3un, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster3_mode[1],poster3_mode[2], col=\"blue\", pch=19)\n    #points(poster3_mean[1],poster3_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    plot_filename<-paste(\"varapprox_post4un_netinst_n\",n,\"_p\",p,\".png\",sep=\"\")\n    plot_filename\n    subtitle<-paste(\"n=\",n,\"; p=\",p,\"; 1st run\", sep=\"\")\n    png(plot_filename)\n    contour(a,b,post4un, nlevels=10,xlab=expression(alpha),ylab=expression(gamma), xlim=c(-2,0),ylim=c(-5,10))\n    points(-1,5,pch=17,col=\"red\")\n    points(poster4_mode[1],poster4_mode[2], col=\"blue\", pch=19)\n    #points(poster4_mean[1],poster4_mean[2], col=\"green3\", pch=18)\n    dev.off()\n    \n    \n    #### TABLE WITH RESULTS ON MEAN, MODE, SD, MLE\n    k4<-kk+4\n    tab[kk:k4,1]<-n\n    tab[kk:k4,2]<-p/100\n    tab[kk:k4,3]<-c(NA,poster1_mean[1],poster2_mean[1],poster3_mean[1],poster4_mean[1])\n    tab[kk:k4,4]<-c(NA,poster1_sd[1],poster2_sd[1],poster3_sd[1],poster4_sd[1])\n    tab[kk:k4,5]<-c(mle_est[1],poster1_mode[1],poster2_mode[1],poster3_mode[1],poster4_mode[1])\n    tab[kk:k4,6]<-c(NA,poster1_mean[2],poster2_mean[2],poster3_mean[2],poster4_mean[2])\n    tab[kk:k4,7]<-c(NA,poster1_sd[2],poster2_sd[2],poster3_sd[2],poster4_sd[2])\n    tab[kk:k4,8]<-c(mle_est[2],poster1_mode[2],poster2_mode[2],poster3_mode[2],poster4_mode[2])\n    \n    kk<-kk+5\n  }\n  \n}\n\n# close text file for cov\nsink()\n\n# save image for additional analysis and reproducibility\nsave.image(\"varapprox_netinst.RData\")\n\n# \n# # to do this with the optimization routine you can use\n# n<-1000\n# p<-50\n# filename<-paste(\"y_rand_netinst_n\",n,\"_p\",p,\".txt\", sep=\"\")\n# filename\n# y<-scan(filename)\n# filename<-paste(\"g_rand_netinst_n\",n,\"_p\",p,\".txt\", sep=\"\")\n# filename\n# gg<-scan(filename)\n# g<-matrix(gg,n,n)\n# g<-t(g)\n# \n# # data summaries\n# sumy<-sum(y)\n# ygy <- as.numeric( t(y) %*% g %*% y )\n# e<-sum(g)\n# ebar<-e/(n-1)\n# \n# \n# res<-optim(par=c(0,0), fn= varloglik, method=c(\"Nelder-Mead\"), control=list(maxit=1000,fnscale=-1))\n# res\n# res<-optim(par=c(0.1,0), fn= varloglik, method=c(\"BFGS\"), control=list(maxit=1000,fnscale=-1))\n# res\n\n\n",
    "created" : 1438634658516.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1115711783",
    "id" : "B4AD7584",
    "lastKnownWriteTime" : 1382621171,
    "path" : "C:/Users/amele1/Dropbox/peersmoking/programs/varapprox_netinst.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}