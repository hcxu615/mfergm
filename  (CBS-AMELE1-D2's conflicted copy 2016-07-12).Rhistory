#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[i] <- kmu[iter]/(n^2)
}
logc
loglikmfR.model1 <- function(theta, n, tobs, ninit = 50) {
# compute potential
potential <- as.numeric(theta[1]*tobs[1] + 0.5*theta[2]*tobs[2])
## mf approximationa
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
tol <- 0.0001
logc <- rep(0,ninit)
for (sim in 1:ninit) {
# create initial symmetric matrix mu
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
mu[lower.tri(mu)] = t(mu)[lower.tri(mu)]
diag(mu) <- 0
# use xi to avoid underflow with logs
xi<-log(mu/(1-mu))
diag(xi) <- 0
kmu <- c()
# compute weighted degrees of each player
degrj <- rowSums(mu)
kmu[1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
eps <- 10
tol<-0.0001
iter<-1
i<-1
nminus1 <- n-1
for (i in 1:nminus1) {
i1<-i+1
for (j in i1:n) {
# xi update
#xijnew <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
#eps <-( 2*theta[1] + (0.5*theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,]))) )*(1/(1+exp(-xijnew))-1/(1+exp(-xi[i,j]))) -
xi[i,j] <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
xi[j,i] <- xi[i,j]
# compute bound
degrj <- rowSums(mu)
kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
#           kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
#             .5*theta[2]*t(1/(1+exp(-xi))) %*% g %*% (1/(1+exp(-xi)))/(n-1) +
#             sum(log(1+exp(xi)) - xi/(1+exp(-xi)))
eps<-abs(kmu[iter+1]-kmu[iter])  # compute change in bound
if (eps<tol) break
iter <- iter+1
#print(iter)
#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[i] <- kmu[iter]/(n^2)
}
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
#loglik <- -loglik
return(loglik)
}
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 2)
# compute potential
potential <- as.numeric(theta[1]*tobs[1] + 0.5*theta[2]*tobs[2])
## mf approximationa
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
tol <- 0.0001
logc <- rep(0,ninit)
for (sim in 1:ninit) {
# create initial symmetric matrix mu
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
mu[lower.tri(mu)] = t(mu)[lower.tri(mu)]
diag(mu) <- 0
# use xi to avoid underflow with logs
xi<-log(mu/(1-mu))
diag(xi) <- 0
kmu <- c()
# compute weighted degrees of each player
degrj <- rowSums(mu)
kmu[1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
eps <- 10
tol<-0.0001
iter<-1
i<-1
nminus1 <- n-1
for (i in 1:nminus1) {
i1<-i+1
for (j in i1:n) {
# xi update
#xijnew <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
#eps <-( 2*theta[1] + (0.5*theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,]))) )*(1/(1+exp(-xijnew))-1/(1+exp(-xi[i,j]))) -
xi[i,j] <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
xi[j,i] <- xi[i,j]
# compute bound
degrj <- rowSums(mu)
kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
#           kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
#             .5*theta[2]*t(1/(1+exp(-xi))) %*% g %*% (1/(1+exp(-xi)))/(n-1) +
#             sum(log(1+exp(xi)) - xi/(1+exp(-xi)))
eps<-abs(kmu[iter+1]-kmu[iter])  # compute change in bound
if (eps<tol) break
iter <- iter+1
#print(iter)
#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[i] <- kmu[iter]/(n^2)
}
logc
kmu
nint
ninit
iter
logc
# compute potential
potential <- as.numeric(theta[1]*tobs[1] + 0.5*theta[2]*tobs[2])
## mf approximationa
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
tol <- 0.0001
logc <- rep(0,ninit)
for (sim in 1:ninit) {
# create initial symmetric matrix mu
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
mu[lower.tri(mu)] = t(mu)[lower.tri(mu)]
diag(mu) <- 0
# use xi to avoid underflow with logs
xi<-log(mu/(1-mu))
diag(xi) <- 0
kmu <- c()
# compute weighted degrees of each player
degrj <- rowSums(mu)
kmu[1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
eps <- 10
tol<-0.0001
iter<-1
i<-1
nminus1 <- n-1
for (i in 1:nminus1) {
i1<-i+1
for (j in i1:n) {
# xi update
#xijnew <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
#eps <-( 2*theta[1] + (0.5*theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,]))) )*(1/(1+exp(-xijnew))-1/(1+exp(-xi[i,j]))) -
xi[i,j] <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
xi[j,i] <- xi[i,j]
# compute bound
degrj <- rowSums(mu)
kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
#           kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
#             .5*theta[2]*t(1/(1+exp(-xi))) %*% g %*% (1/(1+exp(-xi)))/(n-1) +
#             sum(log(1+exp(xi)) - xi/(1+exp(-xi)))
eps<-abs(kmu[iter+1]-kmu[iter])  # compute change in bound
if (eps<tol) break
iter <- iter+1
#print(iter)
#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[sim] <- kmu[iter]/(n^2)
}
logc
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
loglik
#loglik <- -loglik
loglikmfR.model1 <- function(theta, n, tobs, ninit = 50) {
# compute potential
potential <- as.numeric(theta[1]*tobs[1] + 0.5*theta[2]*tobs[2])
## mf approximationa
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
tol <- 0.0001
logc <- rep(0,ninit)
for (sim in 1:ninit) {
# create initial symmetric matrix mu
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
mu[lower.tri(mu)] = t(mu)[lower.tri(mu)]
diag(mu) <- 0
# use xi to avoid underflow with logs
xi<-log(mu/(1-mu))
diag(xi) <- 0
kmu <- c()
# compute weighted degrees of each player
degrj <- rowSums(mu)
kmu[1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
eps <- 10
tol<-0.0001
iter<-1
i<-1
nminus1 <- n-1
for (i in 1:nminus1) {
i1<-i+1
for (j in i1:n) {
# xi update
#xijnew <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
#eps <-( 2*theta[1] + (0.5*theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,]))) )*(1/(1+exp(-xijnew))-1/(1+exp(-xi[i,j]))) -
xi[i,j] <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
xi[j,i] <- xi[i,j]
# compute bound
degrj <- rowSums(mu)
kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
#           kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
#             .5*theta[2]*t(1/(1+exp(-xi))) %*% g %*% (1/(1+exp(-xi)))/(n-1) +
#             sum(log(1+exp(xi)) - xi/(1+exp(-xi)))
eps<-abs(kmu[iter+1]-kmu[iter])  # compute change in bound
if (eps<tol) break
iter <- iter+1
#print(iter)
#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[iter] <- kmu[iter]/(n^2)
}
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
#loglik <- -loglik
return(loglik)
}
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 2)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 20)
# compute potential
potential <- as.numeric(theta[1]*tobs[1] + 0.5*theta[2]*tobs[2])
## mf approximationa
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
tol <- 0.0001
logc <- rep(0,ninit)
for (sim in 1:ninit) {
# create initial symmetric matrix mu
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
mu[lower.tri(mu)] = t(mu)[lower.tri(mu)]
diag(mu) <- 0
# use xi to avoid underflow with logs
xi<-log(mu/(1-mu))
diag(xi) <- 0
kmu <- c()
# compute weighted degrees of each player
degrj <- rowSums(mu)
kmu[1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
eps <- 10
tol<-0.0001
iter<-1
i<-1
nminus1 <- n-1
for (i in 1:nminus1) {
i1<-i+1
for (j in i1:n) {
# xi update
#xijnew <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
#eps <-( 2*theta[1] + (0.5*theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,]))) )*(1/(1+exp(-xijnew))-1/(1+exp(-xi[i,j]))) -
xi[i,j] <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
xi[j,i] <- xi[i,j]
# compute bound
degrj <- rowSums(mu)
kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
#           kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
#             .5*theta[2]*t(1/(1+exp(-xi))) %*% g %*% (1/(1+exp(-xi)))/(n-1) +
#             sum(log(1+exp(xi)) - xi/(1+exp(-xi)))
eps<-abs(kmu[iter+1]-kmu[iter])  # compute change in bound
if (eps<tol) break
iter <- iter+1
#print(iter)
#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[iter] <- kmu[iter]/(n^2)
}
psi_mf <- max(logc)
psi_mf
logc
loglikmfR.model1 <- function(theta, n, tobs, ninit = 50) {
# compute potential
potential <- as.numeric(theta[1]*tobs[1] + 0.5*theta[2]*tobs[2])
## mf approximationa
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
tol <- 0.0001
logc <- rep(0,ninit)
for (sim in 1:ninit) {
# create initial symmetric matrix mu
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
mu[lower.tri(mu)] = t(mu)[lower.tri(mu)]
diag(mu) <- 0
# use xi to avoid underflow with logs
xi<-log(mu/(1-mu))
diag(xi) <- 0
kmu <- c()
# compute weighted degrees of each player
degrj <- rowSums(mu)
kmu[1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
eps <- 10
tol<-0.0001
iter<-1
#i<-1
nminus1 <- n-1
for (i in 1:nminus1) {
i1<-i+1
for (j in i1:n) {
# xi update
#xijnew <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
#eps <-( 2*theta[1] + (0.5*theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,]))) )*(1/(1+exp(-xijnew))-1/(1+exp(-xi[i,j]))) -
xi[i,j] <- 2*theta[1] + (theta[2]/n)* sum(1/(1+exp(-xi[j,])) + 1/(1+exp(-xi[i,])))
xi[j,i] <- xi[i,j]
# compute bound
degrj <- rowSums(mu)
kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
0.5*theta[2]*sum( degrj^2 )/n +
0.5*sum( log(1+exp(xi)) - xi/(1+exp(-xi)) )
#           kmu[iter+1]<-theta[1]*sum(1/(1+exp(-xi))) +
#             .5*theta[2]*t(1/(1+exp(-xi))) %*% g %*% (1/(1+exp(-xi)))/(n-1) +
#             sum(log(1+exp(xi)) - xi/(1+exp(-xi)))
eps<-abs(kmu[iter+1]-kmu[iter])  # compute change in bound
if (eps<tol) break
iter <- iter+1
#print(iter)
#print(eps)
#print(kmu[iter])
#print(kmu[iter+1])
}
}
logc[sim] <- kmu[iter]/(n^2)
}
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
#loglik <- -loglik
return(loglik)
}
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 20)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 2)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 5)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 10)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 5)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 4)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 100)
loglikmfR.model1(c(-1,2), 50, c(0.03,0.005), ninit = 100)
library(mfergm)
simulate.model1(c(-2,3), n=10, nsims=2, cd=TRUE, mfergm=TRUE, mple = TRUE)
simulate.model1(c(-2,3), n=10, nsims=2, cd=TRUE, mfergm=TRUE, mple = FALSE)
simulate.model1(c(-2,3), n=10, nsims=2, cd=TRUE, mfergm=FALSE, mple = TRUE)
simulate.model1(c(-2,3), n=100, nsims=2, cd=TRUE, mfergm=FALSE, mple = TRUE)
0.058*n
0.058*100
library(mfergm)
simulate.model1(c(-2,3), n=100, nsims=2, cd=TRUE, mfergm=TRUE, mple = TRUE)
simulate.model1(c(-2,3), n=100, nsims=2, cd=TRUE, mfergm=FALSE, mple = TRUE)
simulate.model1(c(-2,3), n=100, nsims=2, cd=F, mfergm=T, mple = F)
library(mfergm)
simulate.model1(c(-2,3), n=100, nsims=2, ninit = 2, cd=F, mfergm=T, mple = F)
simulate.model1(c(-2,3), n=20, nsims=2, ninit = 2, cd=F, mfergm=T, mple = F)
simulate.model1(c(-2,3), n=20, nsims=2, ninit = 2, cd=T, mfergm=T, mple = T)
3/20
simulate.model1(c(-2,3), n=50, nsims=2, ninit = 2, cd=T, mfergm=T, mple = T)
simulate.model1(c(-2,3), n=30, nsims=2, ninit = 2, cd=T, mfergm=T, mple = T)
library(mfergm)
simulate.model1(c(-2,3), n=30, nsims=2, ninit = 2, cd=T, mfergm=T, mple = T)
simulate.model1(c(-2,3), n=30, nsims=2, ninit = 10, cd=T, mfergm=T, mple = T)
library(mfergm)
simulate.model1(c(-2,3), n=30, nsims=2, ninit = 10, cd=T, mfergm=T, mple = T)
simulate.model1(c(-2,3), n=20, nsims=2, ninit = 10, cd=T, mfergm=T, mple = T)
library(mfergm)
simulate.model1(c(-2,3), n=20, nsims=2, ninit = 10, cd=T, mfergm=T, mple = T)
simulate.model1(c(-2,3), n=50, nsims=2, ninit = 10, cd=T, mfergm=T, mple = T)
simulate.model1(c(-2,3), n=50, nsims=5, ninit = 10, cd=T, mfergm=T, mple = T)
loglik.model1(c(-2,3), tobs)
loglik.model1(c(-2,3), c(0.0200 ,0.000416))
loglikmfR.model1(c(-2,3), c(0.0200 ,0.000416))
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=50 )
library(mfergm)
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=50 )
library(mfergm)
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
loglikmfR.model1( c(-2,3), 50, c(0.0200 ,0.000416), ninit=10 )
log(10#-30)
))
log(10E-30)
log(1E-30)
log(1E-300)
log(1E-3000000)
log(1E-300000)
log(1E-30000)
log(1E-3000)
log(1E-300)
log(1E-344)
log(1E-343)
log(1E-342)
log(1E-341)
log(1E-322)
log(1E-333)
log(1E-330)
log(1E-328)
log(1E-324)
log(1E-325)
log(1E-322)
log(1E-323)
log(1E-324)
log(1E-323)
class(log(1E-323))
as.double(log(1E-323))
library(mfergm)
library(devtools)
install.packages(devtolls)
install.packages(devtools)
install.packages("devtools")
sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
install.packages("Rtools")
install.packages("RTools")
library(tools)
tools
?tools
Sys.getenv("path")
Sys.getenv("path")
Sys.getenv("path")
Sys.which(gfortran.exe)
Sys.which("gfortran.exe")
Sys.getenv("path")
install.packages("rootSolve")
Sys.getenv("path")
Sys.which("gfortran")
Sys.getenv("path")
Sys.getenv("path")
Sys.which("gfortran")
library(mfergm)
