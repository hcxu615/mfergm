loglik <- potential - psi_mf
loglik
### check if mfergm works fine
# library mfergm (also loads ergm, networks)
library(mfergm)
# set seed
set.seed(1977)
# size of the network
n <- 100
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
# true parameters
theta = c(-1.0,2.0)
# tolerance for mf
tol = 0.000001
## create network from random erdos renyi
#g <- network(matrix(rbinom(n^2,1,exp(theta[1]/(1+exp(theta[1]) )  )),
#                    nrow = n, ncol = n), directed = FALSE)
g <- initialize.network(theta, n, directed = FALSE)
## generate network from simulation of ergm
g0 <- simulate(~edges+kstar(2),
nsim = 1,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=1000000,
MCMC.interval=100)
)
g0
g0 <- simulate(~edges+kstar(2),
nsim = 50,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=10000000,
MCMC.interval=10000)
)
g0
tobs <- data.frame(matrix(NA,ncol =2 , nrow = 50))
for (i in 1:50) {
formula <- g0[[i]] ~ edges + kstar(2)
tobs[i,] <- summary(formula)/(c((n^2)/2, n^3))
}
# the following works fine, so you can create a loop on the
# formulas for each graph
formula <- g0[[1]] ~ edges + kstar(2)
## compute suff stats for the simulated network
#formula <- g0 ~ edges + kstar(2)
tobs <- summary(formula)/(c((n^2)/2, n^3))
tobs
sum(theta*tobs)
potential <- theta %*% tobs
## mf approximation
nsim <- 10 # number of re-starts of the algorithm
maxiter <- 50
logc <- rep(0,nsim)
for (sim in 1:nsim) {
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
diag(mu) <- 0
psi <- logconstant_mf2(p, mu, theta, x, dt, tol, maxiter)
psi$psi
logc[sim] <- psi$psi
}
logc
sort(logc)
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
?logconstant_mf2
?roxygen
library(devtools)
?roxygenize
??roxygenize
install.packages("roxygen")
install.packages("roxygen2")
library(mfergm)
?logconstant_mf2
roxygenize
roxygenize()
devtools::document()
library(mfergm)
?logconstant_mf2
library(mfergm)
n <- 10   # small network
x <- rnorm(n,0,1)  #attributes
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n) #initialize matrix mu
diag(mu) <- 0  #make sure mu has 0 diagonal
# Now let's get the variational mean-field aprpoximation
p <- c(1,2)  # 2 variables only
q <- 1   # x has only 1 column
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)  # which column of x to consider
dt[,2] <- c(1,1)  # which change stats to use
theta = c(-3.0,1.5)  # parameters
tol = 0.000001   # tolerance
psi <- logconstant_mf2(p, mu, theta, x, dt, tol)  #compute log-constant
psi$psi
psi
n <- 100   # small network
x <- rnorm(n,0,1)  #attributes
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n) #initialize matrix mu
diag(mu) <- 0  #make sure mu has 0 diagonal
# Now let's get the variational mean-field aprpoximation
p <- c(1,2)  # 2 variables only
q <- 1   # x has only 1 column
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)  # which column of x to consider
dt[,2] <- c(1,1)  # which change stats to use
theta = c(-3.0,1.5)  # parameters
tol = 0.000001   # tolerance
psi <- logconstant_mf2(p, mu, theta, x, dt, tol)  #compute log-constant
psi$psi
n <- 100   # small network
x <- rnorm(n,0,1)  #attributes
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n) #initialize matrix mu
diag(mu) <- 0  #make sure mu has 0 diagonal
# Now let's get the variational mean-field aprpoximation
p <- c(1,2)  # 2 variables only
q <- 1   # x has only 1 column
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)  # which column of x to consider
dt[,2] <- c(1,1)  # which change stats to use
theta = c(-3.0,1.5)  # parameters
tol = 0.000001   # tolerance
psi <- logconstant_mf2(p, mu, theta, x, dt, tol)  #compute log-constant
psi$psi
n <- 1000   # small network
x <- rnorm(n,0,1)  #attributes
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n) #initialize matrix mu
diag(mu) <- 0  #make sure mu has 0 diagonal
# Now let's get the variational mean-field aprpoximation
p <- c(1,2)  # 2 variables only
q <- 1   # x has only 1 column
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)  # which column of x to consider
dt[,2] <- c(1,1)  # which change stats to use
theta = c(-3.0,1.5)  # parameters
tol = 0.000001   # tolerance
psi <- logconstant_mf2(p, mu, theta, x, dt, tol)  #compute log-constant
psi$psi
library(devtools)
Sys.getenv("PATH")
find_rtools()
library(devtools)
find_rtools()
library(mfergm)
library(mfergm)
library(mfergm)
library(mfergm)
library(mfergm)
simulate.model1(c(-1,2), n=1, nsims = 1, ninit = 5, mfergm = TRUE)
simulate.model1(c(-1,2), n=1, nsims = 2, ninit = 5, mfergm = TRUE)
install.packages("optimx")
simulate.model1(c(-1,2), n=1, nsims = 2, ninit = 5, mfergm = TRUE)
simulate.model1(c(-2,2), n=1, nsims = 2, ninit = 5, mfergm = TRUE)
tobs
simulate.model1(c(-2,2), n=1, nsims = 2, ninit = 1, mfergm = TRUE)
simulate.model1(c(-2,2), n=1, nsims = 2, ninit = 1, mfergm = TRUE)
simulate.model1(c(-2,2), n=1, nsims = 2, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=10, nsims = 2, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=100, nsims = 2, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=10, nsims = 2, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=10, nsims = 1, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=10, nsims = 2, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=10, nsims = 2, ninit = 1, mfergm = TRUE, cd = FALSE)
simulate.model1(c(-2,2), n=10, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,2), n=100, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,2), n=100, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,12), n=100, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,1), n=100, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,-1), n=100, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,-2), n=100, nsims = 2, ninit = 1, cd = TRUE)
simulate.model1(c(-2,-2), n=100, nsims = 10, ninit = 1, cd = TRUE)
simulate.model1(c(-2,4), n=100, nsims = 10, ninit = 1, cd = TRUE)
simulate.model1(c(-2,4), n=100, nsims = 10, ninit = 10, cd = TRUE)
simulate.model1(c(-2,4), n=100, nsims = 10, ninit = 10, cd = TRUE)
simulate.model1(c(-2,4), n=100, nsims = 10, ninit = 10, cd = FALSE)
simulate.model1(c(-2,4), n=100, nsims = 10, ninit = 10, cd = FALSE, mfergm = TRUE)
library(mfergm)
simulate.model1(c(-2,4), n=100, nsims = 10, ninit = 10, cd = FALSE, mfergm = TRUE)
simulate.model1(c(-2,0), n=100, nsims = 10, ninit = 10, cd = FALSE, mfergm = TRUE)
### check if mfergm works fine
# library mfergm (also loads ergm, networks)
library(mfergm)
# set seed
set.seed(1977)
# size of the network
n <- 100
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
# true parameters
theta = c(-1.0,2.0)
# tolerance for mf
tol = 0.000001
## create network from random erdos renyi
#g <- network(matrix(rbinom(n^2,1,exp(theta[1]/(1+exp(theta[1]) )  )),
#                    nrow = n, ncol = n), directed = FALSE)
g <- initialize.network(theta, n, directed = FALSE)
## generate network from simulation of ergm
g0 <- simulate(~edges+kstar(2),
nsim = 1,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=1000000,
MCMC.interval=100)
)
g0
g0 <- simulate(~edges+kstar(2),
nsim = 50,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=10000000,
MCMC.interval=10000)
)
g0
tobs <- data.frame(matrix(NA,ncol =2 , nrow = 50))
for (i in 1:50) {
formula <- g0[[i]] ~ edges + kstar(2)
tobs[i,] <- summary(formula)/(c((n^2)/2, n^3))
}
# the following works fine, so you can create a loop on the
# formulas for each graph
formula <- g0[[1]] ~ edges + kstar(2)
## compute suff stats for the simulated network
#formula <- g0 ~ edges + kstar(2)
tobs <- summary(formula)/(c((n^2)/2, n^3))
tobs
sum(theta*tobs)
potential <- theta %*% tobs
## mf approximation
nsim <- 10 # number of re-starts of the algorithm
maxiter <- 50
logc <- rep(0,nsim)
for (sim in 1:nsim) {
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
diag(mu) <- 0
psi <- logconstant_mf2(p, mu, theta, x, dt, tol, maxiter)
psi$psi
logc[sim] <- psi$psi
}
logc
sort(logc)
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
### solution 1: grid of parameters, evaluate log-likelihood
###             at each grid point, interpolate
formula <- g0 ~ edges + kstar(2)
tobs <- summary(formula)
for (i in 1:dim(tobs)[1]) {
tobs[i,] <- tobs[i,]/c(n^2, n^3)
}
a <- seq(-3,5,.5)
b <- seq(-20,20,1)
a <- seq(-5,5,.5)
b <- seq(-5,10,.5)
loglik_grid <- matrix(NA, nrow = length(a), ncol = length(b))
## loop around the grid
for (i1 in 1:length(a)) {
for (j1 in 1: length(b)) {
## to compute suff stats
theta <- c(a[i1],b[j1])
## compute potential
potential <-theta %*% tobs
## mf approximation
nsim <- 50 # number of re-starts of the algorithm
logc <- rep(0,nsim)
for (sim in 1:nsim) {
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
diag(mu) <- 0
psi <- logconstant_mf(p, mu, theta, x, dt, tol)
psi$psi
logc[sim] <- psi$psi
}
psi_mf <- max(logc)
# compute log likelihood value
loglik <- potential - psi_mf
loglik_grid[i1,j1] <- loglik
}
}
contour(a,b,loglik_grid, nlevels=100,
xlab=expression(alpha),
ylab=expression(gamma),
xlim=c(-4,-2),ylim=c(0,1))
library(mfergm)
simulate.model1(c(-2,0), n=100, nsims = 10, ninit = 10, cd = FALSE, mfergm = TRUE)
### check if mfergm works fine
# library mfergm (also loads ergm, networks)
library(mfergm)
# set seed
set.seed(1977)
# size of the network
n <- 100
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
# true parameters
theta = c(-1.0,2.0)
# tolerance for mf
tol = 0.000001
## create network from random erdos renyi
#g <- network(matrix(rbinom(n^2,1,exp(theta[1]/(1+exp(theta[1]) )  )),
#                    nrow = n, ncol = n), directed = FALSE)
g <- initialize.network(theta, n, directed = FALSE)
## generate network from simulation of ergm
g0 <- simulate(~edges+kstar(2),
nsim = 1,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=1000000,
MCMC.interval=100)
)
g0
g0 <- simulate(~edges+kstar(2),
nsim = 50,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=10000000,
MCMC.interval=10000)
)
g0
tobs <- data.frame(matrix(NA,ncol =2 , nrow = 50))
for (i in 1:50) {
formula <- g0[[i]] ~ edges + kstar(2)
tobs[i,] <- summary(formula)/(c((n^2)/2, n^3))
}
# the following works fine, so you can create a loop on the
# formulas for each graph
formula <- g0[[1]] ~ edges + kstar(2)
## compute suff stats for the simulated network
#formula <- g0 ~ edges + kstar(2)
tobs <- summary(formula)/(c((n^2)/2, n^3))
tobs
sum(theta*tobs)
potential <- theta %*% tobs
nsim <- 10 # number of re-starts of the algorithm
maxiter <- 50
logc <- rep(0,nsim)
for (sim in 1:nsim) {
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
diag(mu) <- 0
psi <- logconstant_mf2(p, mu, theta, x, dt, tol, maxiter)
psi$psi
logc[sim] <- psi$psi
}
library(mfergm)
### check if mfergm works fine
# library mfergm (also loads ergm, networks)
library(mfergm)
# set seed
set.seed(1977)
# size of the network
n <- 100
# attributes
x <- rnorm(n,0,1)
# parameters location
p <- c(1,2)
q <- 1
# change stats to use
dt <- matrix(0, ncol = p[2], nrow = 2)
dt[,1] <- c(1,1)
dt[,2] <- c(1,1)
# true parameters
theta = c(-1.0,2.0)
# tolerance for mf
tol = 0.000001
## create network from random erdos renyi
#g <- network(matrix(rbinom(n^2,1,exp(theta[1]/(1+exp(theta[1]) )  )),
#                    nrow = n, ncol = n), directed = FALSE)
g <- initialize.network(theta, n, directed = FALSE)
## generate network from simulation of ergm
g0 <- simulate(~edges+kstar(2),
nsim = 1,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=1000000,
MCMC.interval=100)
)
g0
g0 <- simulate(~edges+kstar(2),
nsim = 50,
coef = theta*c(2,1/n ),
basis = g,
control=control.simulate(
MCMC.burnin=10000000,
MCMC.interval=10000)
)
g0
tobs <- data.frame(matrix(NA,ncol =2 , nrow = 50))
for (i in 1:50) {
formula <- g0[[i]] ~ edges + kstar(2)
tobs[i,] <- summary(formula)/(c((n^2)/2, n^3))
}
# the following works fine, so you can create a loop on the
# formulas for each graph
formula <- g0[[1]] ~ edges + kstar(2)
## compute suff stats for the simulated network
#formula <- g0 ~ edges + kstar(2)
tobs <- summary(formula)/(c((n^2)/2, n^3))
tobs
sum(theta*tobs)
potential <- theta %*% tobs
## mf approximation
nsim <- 10 # number of re-starts of the algorithm
maxiter <- 50
logc <- rep(0,nsim)
for (sim in 1:nsim) {
mu <- matrix(runif(n^2,0,1), nrow = n, ncol = n)
diag(mu) <- 0
psi <- logconstant_mf2(p, mu, theta, x, dt, tol, maxiter)
psi$psi
logc[sim] <- psi$psi
}
simulate.model1(c(-2,0), n=100, nsims = 10, ninit = 10, cd = FALSE, mfergm = TRUE)
simulate.model1(c(-2,0), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = FALSE, mfergm = TRUE)
simulate.model1(c(-2,2), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = FALSE, mfergm = TRUE)
simulate.model1(c(-2,2), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE)
simulate.model1(c(-2,4), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE)
simulate.model1(c(-2,3), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE)
simulate.model1(c(-2,3), n=100, nsims = 10, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE)
simulate.model1(c(-2,3), n=100, nsims = 10, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
library(mfergm)
library(mfergm)
simulate.model1(c(-2,3), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-2,3), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-2,1), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,3), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,2), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,5), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,4), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-4,3), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-4,5), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
library(mfergm)
simulate.model1(c(-4,5), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-4,7), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-4,17), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-4,33), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,33), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,7), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,7), n=300, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
library(mfergm)
simulate.model1(c(-3,7), n=30, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,7), n=50, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,10), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,10), n=100, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,10), n=300, nsims = 5, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-3,10), n=300, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
warnings()
simulate.model1(c(-3,4), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
simulate.model1(c(-2,4), n=100, nsims = 2, ninit = 5, ergm = TRUE,  cd = TRUE, mfergm = TRUE, mple = TRUE)
?mcmc.diagnostics
?gof
g0
gof(g0[[1]] ~ edges + kstar(2), coef = c(-2.119687*2, 3.993316/100 ))
goftry<-gof(g0[[1]] ~ edges + kstar(2), coef = c(-2.119687*2, 3.993316/100 ))
plot(goftry)
goftry<-gof(g0[[1]] ~ edges + kstar(2) + triangles, coef = c(-2.119687*2, 3.993316/100 ))
goftry<-gof(g0[[1]] ~ edges + kstar(2) , coef = c(-2.119687*2, 3.993316/100 ))
goftry<-gof(g0[[1]] ~ edges + kstar(2) , coef = c(-2*2, 4/100 ))
plot(goftry)
library(mfergm)
simulate.model1(c(-2,1), n = 100, nsims = 10, ninit = 10, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
sims1 <- simulate.model1(c(-2,1), n = 100, nsims = 10, ninit = 10, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
sims1 <- simulate.model1(c(-2,1), n = 100, nsims = 10, ninit = 10, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
sims1
colMean(sims1)
colsMean(sims1)
colMeans(sims1)
?colMeans
colMeans(sims1)
colMeans(sims1$estimates)
-3.86/2
0.029*100
library(mfergm)
sims1 <- simulate.model1(c(-2,1), n = 100, nsims = 3, ninit = 10, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
colMeans(sims1$estimates)
warnings()
library(mfergm)
sims1 <- simulate.model1(c(-2,1), n = 100, nsims = 3, ninit = 10, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
library(mfergm)
sims1 <- simulate.model1(c(-2,1), n = 100, nsims = 3, ninit = 10, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
colMeans(sims1$estimates)
sims1 <- simulate.model1(c(-2,1), n = 100, nsims = 3, ninit = 2, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
colMeans(sims1$estimates)
sims1 <- simulate.model1(c(-2,1), n = 200, nsims = 3, ninit = 2, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
colMeans(sims1$estimates)
sims1 <- simulate.model1(c(-2,1), n = 500, nsims = 3, ninit = 2, ergm = TRUE, cd = TRUE, mfergm = TRUE, mple = TRUE)
